#include <stdio.h>  
#include <stdlib.h>
/*
这一句话是必须要的格式
stdio 表示系统文件库, 也可以声明其它的
.h  表示头文件,因为这些文件都是放在程序各文件的开头
#include 告诉预处理器将指定头文件的内容插入到预处理器命令的相应位  导入头文件的预编译指令
<> 表示系统自带的库
也可以写成" " 表示用户自定义的库
如果写成" "并且自定义的库里面没有这个文件系统会自动查找自带的库,如果还是没有就会报错
"acv" 'a'

“悬空指针”是指向被释放内存的指针，“野指针”则是不确定其具体指向的指针。“野指针”最常来自于未初始化的指针
*/
#include <float.h>

// 类型决定了变量存储的大小和布局
int main3()
{
	printf("float 存储最大字节数 : %lu \n", sizeof(float));
	printf("float 最小值: %E\n", FLT_MIN);
	printf("float 最大值: %E\n", FLT_MAX);
	printf("精度值: %d\n", FLT_DIG);
	
	system("pause");
	return 0;
}
int main1() // 程序的入口
{ //程序从这里开始运行
	/*
	int 表示数字格式,返回一个数字
	main()主函数 表示程序的入口  一个程序有且只能有一个main函数的存在
	*/
	printf("hello C\n"); //打印一个hello C
	return 0; //返回一个整数0,因为它是int类型,所以只能返回整数
}  //程序从这里结束

/*
1. extern int a;     // 声明一个全局变量 a
2. int a;            // 定义一个全局变量 a
3. extern int a = 0;  // 定义一个全局变量 a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间
4. int a = 0;         //定义一个全局变量 a，并给初值

声明之后你不能直接使用这个变量，需要定义之后才能使用。
但是定义只能出现在一处。也就是说，不管是 int a 还是 int a=0 都只能出现一次，而那个 extern int a 可以出现很多次。
当你要引用一个全局变量的时候，你就要声明 extern int a 这时候 extern 不能省略，因为省略了，就变成 int a 这是一个定义，不是声明。

变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。
变量声明：用于向程序表明变量的类型和名字。
定义也是声明，extern 声明不是定义。
定义也是声明：当定义变量时我们声明了它的类型和名字。
extern 声明不是定义：通过使用 extern 关键字声明变量名而不定义它。

[注意]
变量在使用前就要被定义或者声明。
在一个程序中，变量只能定义一次，却可以声明多次。
定义分配存储空间，而声明不会。
*/

/*
1、 当需要保存数据的时候，需要lvalues。
2、 当需要读取数据的时候，需要rvalues。

lvalues 和 rvalues 角色的相互转换
1、 根据表达式的上下文情况，lvalues 在需要 rvalues 的地方会自动转换为 rvalues。例如:

	int n;

	int m;

	m = n+2; // 这个表达式里 n 是 rvalues
2、 rvalues 永远不能转换为 lvalues

*/

/*
内存寻址由大到小，优先分配内存地址比较大的字节给变量，所以说变量越先定义，内存地址就越大
变量地址的获取方式：& 变量名。
一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值
*/

int main2()
{

	int a;
	int b;

	printf("a的地址是%p\nb的地址是%p\n",&a,&b);  // a的地址比b的地址大 

	system("pause");
	return 0;
}
/*
C99 提供了 _Bool 型，所以布尔类型可以声明为 _Bool flag。
_Bool 依然仍是整数类型，但与一般整型不同的是，_Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。
C99还提供了一个头文件 <stdbool.h> 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。
*/

//导入 stdbool.h 来使用布尔类型
#include <stdbool.h>

//计算n!,n的值在main中定义
int main4(){
	int n = 10;    //计算叠乘数
	int sum = 1; //用来存放叠乘的结果
	bool flag = false;    //叠乘标记

	int num = n;    //循环次数
	while( !flag ){ // num>1时, !flag就代表真, num=1时,!flag为假 结束循环
		sum = sum * (num--);
		//当num=1时结束循环
		if( num == 1){
			flag = true;
		}
	}
	printf ("%d的叠乘值为 %d \n", n, sum);

	system("pause");
	return 0;
}

/*
全局变量和局部变量在内存中的区别

1. 全局变量保存在内存的全局存储区中，占用静态的存储单元；
2. 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

C语言经过编译之后将内存分为以下几个区域：

（1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。
（2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。
（3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。
（4）文字常量区：存放常量字符串。程序结束后由系统释放。
（5）程序代码区：存放程序的二进制代码。
显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。
*/

int k1 = 1;
int k2;
static int k3 = 2;
static int k4;
int main()
{
	static int m1 = 2, m2;
	int i = 1;
	char*p;
	char str[10] = "hello";
	char*q = "hello";
	p = (char *)malloc(100); 
		
	free(p);
	printf("栈区-变量地址  i：%p\n", &i); // ：001EFDB4
	printf("                p：%p\n", &p); // 001EFDA8
	printf("              str：%p\n", str); // 001EFD94
	printf("                q：%p\n", &q); // 001EFD88
	printf("堆区地址-动态申请：%p\n", p); // 00539F18
	printf("全局外部有初值 k1：%p\n", &k1); // 较小 0085802C
	printf("    外部无初值 k2：%p\n", &k2); // 较大 00858168     外动无大于外静无
	printf("静态外部有初值 k3：%p\n", &k3); // 较小：00858030     外静大于外动
	printf("    外静无初值 k4：%p\n", &k4); // 较大：00858154
	printf("  内静态有初值 m1：%p\n", &m1);// ：00858034         无初值大于有初值
	printf("  内静态无初值 m2：%p\n", &m2);// ：00858158
	// 外初有 < 外静有 < 内静有      外静无 < 染参 < 外初无

	printf("文字常量地址    ：%p, %s\n", q, q);// ：008558D8
	printf("程序区地址      ：%p\n", &main);// 00851145

	system("pause");
	return 0;
}
// 在一个表达式中，左值必须是变量，右值可以是变量，常量或者表达式